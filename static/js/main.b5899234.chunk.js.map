{"version":3,"sources":["data/gtfs/agency.txt","data/gtfs/calendar.txt","data/gtfs/calendar_dates.txt","data/gtfs/frequencies.txt","data/gtfs/routes.txt","data/gtfs/stop_times.txt","data/gtfs/stops.txt","data/gtfs/trips.txt","lib/gtfs/utils.ts","lib/set-utils.ts","lib/time.ts","lib/multileg.ts","lib/gtfs/trips.ts","components/MultilegTable.tsx","components/ReactVisjsTimeline.tsx","components/MultilegTimeline.tsx","tribalKnowledge.tsx","components/TimeConfig.tsx","components/RouteConfig.tsx","components/ConfigSection.tsx","components/MultilegGraph.tsx","lib/gtfs/parse.ts","app-data.ts","App.tsx","index.tsx"],"names":["module","exports","getValidServiceIdsForTime","gtfsData","t","dateYMD","formatDate","weekday","getUTCDay","calendarServiceIds","calendar","filter","ce","dateValid","start_date","end_date","weekdayValid","sunday","monday","tuesday","wednesday","thursday","friday","saturday","map","service_id","addServiceIds","calendarDates","cd","date","exception_type","delServiceIds","set1","sOut","Set","sets","forEach","set","v","delete","intersect","add","union","hmsToDaySeconds","h","m","s","hmsStringToTriple","hmsString","split","bit","parseInt","LegType","computeSingleLeg","startTime","startStopId","endStopId","trips","tripStopFromToMap","possibleTripIds","Array","from","availableServiceIds","possibleTripServiceIds","tripId","tripMap","index","trip","has","undefined","Boolean","getValidTripsForStopPair","startTimeDS","getHours","getMinutes","getSeconds","hmsStringToDaySeconds","tripStopSequences","trip_id","departure_time","MultilegMachine","driveTimes","driveMultipliers","disembarkTimeMin","maxFerryOptions","this","stopId1","stopId2","stop1","stopMap","stop2","stop_name","legs","length","leg","nextLegs","Error","ferryNext","_findFerry","driveNext","_findDrive","id","type","ERROR","text","describeTrip","endTime","next","ferryTrips","slice","stops","dh","dm","ds","arrival_time","ah","am","as","tripStart","datefns","hours","minutes","seconds","tripEnd","FERRY","trip_headsign","computeMultilegBitRecur","stopsKey","mul","DRIVE","remark","toFixed","stopIds","i","push","stopSequenceToLegs","legSuccessors","legPredecessors","walk","previous","thisLegPredecessors","pleg","nleg","Object","keys","legId","plegId","MultilegTableRow","props","parentLeg","depth","accumulatedDuration","accumulatedWait","result","highlight","setHighlight","typeLogo","WAIT","getLegTypeLogo","wait","legDuration","newAccumulatedDuration","newAccumulatedWait","final","classes","initial","faded","className","cx","onClick","style","paddingLeft","childLeg","key","MultilegTable","interactive","events","Timeline","options","items","groups","eventHandlers","containerRef","React","useRef","timelineRef","eventHandlersRef","useEffect","current","onEvent","useCallback","eventType","arg","handlers","timeline","setOptions","setItems","VisTimeline","on","setGroups","destroy","ref","width","stack","showCurrentTime","MultilegTimeline","useMemo","itemMap","groupMap","itemClasses","itemPredecessors","l","itemId","groupId","endStopName","content","group","start","end","values","select","defaultRouteStopNames","driveTravelTimes","rawDriveTimeData","s1","s2","duration","jsDateFormatter","parseDate","str","Date","TimeConfig","onChange","display","flex","showActionsBar","value","isUserChange","RouteConfig","setStopIds","lastStopId","nextStops","stopId","destSet","fromStop","toStop","stop_id","getDestinationStopsFromStop","fromStopId","toStopId","nextSelect","disabled","size","e","selection","target","concat","sortBy","name","idx","large","onRemove","sid","marginRight","marginTop","icon","reverse","ConfigSection","margin","onChangeDate","label","min","max","stepSize","labelStepSize","setDisembarkTimeMin","setDriveTimeMultiplier","driveTimeMultiplier","MultilegGraph","nodes","edges","startId","endId","stop","data","stopNode","edgeId","edgeLabel","source","elements","stylesheet","selector","layout","nodeDimensionsIncludeLabels","klay","direction","edgeRouting","height","border","cytoscape","use","urlMap","a","promises","fetch","resp","ok","statusText","replace","trim","papaparse","parse","header","errors","console","warn","Promise","all","results","fromEntries","augmentRawGTFSData","rawData","groupBy","stopTimes","st","getTripStopFromToMap","routeMap","keyBy","routes","filterAndAugmentRawData","cutoffDate","dateCutoff","dateCutoffYMD","filterRawGTFSData","loadRawDataRequire","parseMultipleUrls","agency","require","frequencies","ResultTabs","renderActiveTabPanelOnly","title","panel","viewProps","renderButton","Expander","active","buttonActive","onButtonClick","Core","useState","setStartTime","find","startsWith","splitEnabled","setSplitEnabled","mlm","uniq","computeMultileg","resultView","join","parseFloat","App","setGtfsData","getFilteredGTFSData","then","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.b5899234.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/agency.e3fe3559.txt\";","module.exports = __webpack_public_path__ + \"static/media/calendar.71341278.txt\";","module.exports = __webpack_public_path__ + \"static/media/calendar_dates.f273cdc8.txt\";","module.exports = __webpack_public_path__ + \"static/media/frequencies.fb971eb9.txt\";","module.exports = __webpack_public_path__ + \"static/media/routes.69a02baf.txt\";","module.exports = __webpack_public_path__ + \"static/media/stop_times.ea3ed20e.txt\";","module.exports = __webpack_public_path__ + \"static/media/stops.d8863e08.txt\";","module.exports = __webpack_public_path__ + \"static/media/trips.703ef61b.txt\";","import { FromToTripMap, GTFSData, StopTime } from \"./types\";\nimport formatDate from \"date-fns/format\";\nimport { intersect, union } from \"../set-utils\";\nimport { Dictionary } from \"lodash\";\n\nexport function getTripStopFromToMap(\n  tripStopSequences: Dictionary<StopTime[]>\n): FromToTripMap {\n  const tripStopFromToMap: FromToTripMap = {};\n  for (let tripId in tripStopSequences) {\n    const stops = tripStopSequences[tripId];\n    if (stops.length !== 2) {\n      // TODO: support trips with more than 2 stops?\n      //console.warn(`trip ${tripId} has more than 2 stops?`, stops);\n      continue;\n    }\n    const [fromStop, toStop] = stops;\n    const key = `${fromStop.stop_id},${toStop.stop_id}`;\n    if (!tripStopFromToMap[key]) {\n      tripStopFromToMap[key] = new Set();\n    }\n    tripStopFromToMap[key].add(tripId);\n  }\n  return tripStopFromToMap;\n}\n\nexport function getDestinationStopsFromStop(\n  gtfsData: GTFSData,\n  stopId: string | null\n): Set<string> {\n  const destSet = new Set<string>();\n  for (let tripId in gtfsData.tripStopSequences) {\n    const stops = gtfsData.tripStopSequences[tripId];\n    if (stops.length !== 2) {\n      // TODO: support trips with more than 2 stops?\n      continue;\n    }\n    const [fromStop, toStop] = stops;\n    if (stopId === null) {\n      // If no stop was defined, get all the initial stops we\n      // know have outward routes.\n      destSet.add(fromStop.stop_id);\n    } else if (fromStop.stop_id === stopId) {\n      destSet.add(toStop.stop_id);\n    }\n  }\n  return destSet;\n}\n\nexport function getValidServiceIdsForTime(gtfsData: GTFSData, t: Date) {\n  const dateYMD = formatDate(t, \"yyyyMMdd\");\n  const weekday = t.getUTCDay(); // 0 = sunday\n  const calendarServiceIds = gtfsData.calendar\n    .filter((ce) => {\n      // console.log(ce.service_id, dateYMD, ce.start_date, ce.end_date);\n      const dateValid = ce.start_date <= dateYMD && dateYMD <= ce.end_date;\n      const weekdayValid =\n        (weekday === 0 && ce.sunday === \"1\") ||\n        (weekday === 1 && ce.monday === \"1\") ||\n        (weekday === 2 && ce.tuesday === \"1\") ||\n        (weekday === 3 && ce.wednesday === \"1\") ||\n        (weekday === 4 && ce.thursday === \"1\") ||\n        (weekday === 5 && ce.friday === \"1\") ||\n        (weekday === 6 && ce.saturday === \"1\");\n      return dateValid && weekdayValid;\n    })\n    .map((ce) => ce.service_id);\n  // 1 - Service has been added for the specified date.\n  // 2 - Service has been removed for the specified date.\n  const addServiceIds = gtfsData.calendarDates\n    .filter((cd) => cd.date === dateYMD && cd.exception_type === \"1\")\n    .map((cd) => cd.service_id);\n  const delServiceIds = gtfsData.calendarDates\n    .filter((cd) => cd.date === dateYMD && cd.exception_type === \"2\")\n    .map((cd) => cd.service_id);\n  //console.log(t, \"si\", calendarServiceIds, addServiceIds, delServiceIds);\n  return intersect(\n    union(new Set(calendarServiceIds), new Set(addServiceIds)),\n    new Set(delServiceIds)\n  );\n}\n","export function union<T>(...sets: Set<T>[]): Set<T> {\n  const sOut = new Set<T>();\n  sets.forEach((set) => set.forEach((v) => sOut.add(v)));\n  return sOut;\n}\n\nexport function intersect<T>(set1: Set<T>, ...sets: Set<T>[]): Set<T> {\n  const sOut = new Set<T>(set1);\n  sets.forEach((set) => set.forEach((v) => sOut.delete(v)));\n  return sOut;\n}\n","export function hmsToDaySeconds(h: number, m: number, s: number): number {\n  return h * 60 * 60 + m * 60 + s;\n}\n\nexport function hmsStringToTriple(hmsString: string): [number, number, number] {\n  const [h, m, s] = hmsString.split(\":\").map((bit) => parseInt(bit, 10));\n  return [h, m, s];\n}\n\nexport function hmsStringToDaySeconds(hmsString: string): number {\n  const [h, m, s] = hmsStringToTriple(hmsString);\n  return hmsToDaySeconds(h, m, s);\n}\n\nexport function dateToDaySeconds(date: Date): number {\n  const h = date.getHours();\n  const m = date.getMinutes();\n  const s = date.getSeconds();\n  return hmsToDaySeconds(h, m, s);\n}\n","import {GTFSData, Trip} from \"./gtfs/types\";\nimport {getValidTripsForStopPair} from \"./gtfs/trips\";\nimport {\n  dateToDaySeconds,\n  hmsStringToDaySeconds,\n  hmsStringToTriple,\n} from \"./time\";\nimport * as datefns from \"date-fns\";\nimport {start} from \"repl\";\n\nexport type InterstopMap = { [pair: string]: number };\n\nexport function computeSingleLeg(\n  gtfsData: GTFSData,\n  startTime: Date,\n  startStopId: string,\n  endStopId: string\n): Trip[] {\n  const trips = getValidTripsForStopPair(\n    gtfsData,\n    startTime,\n    startStopId,\n    endStopId\n  );\n  const startTimeDS = dateToDaySeconds(startTime);\n  return trips.filter((t) => {\n    const stops = gtfsData.tripStopSequences[t.trip_id];\n    return hmsStringToDaySeconds(stops[0].departure_time) >= startTimeDS;\n  });\n}\n\ntype LegFromToList = Array<[string, string]>;\n\nfunction stopSequenceToLegs(stopIds: string[]): LegFromToList {\n  const legs: LegFromToList = [];\n  for (var i = 1; i < stopIds.length; i++) {\n    legs.push([stopIds[i - 1], stopIds[i]]);\n  }\n  return legs;\n}\n\nexport enum LegType {\n  ERROR = \"error\",\n  WAIT = \"wait\",\n  DRIVE = \"drive\",\n  FERRY = \"ferry\",\n}\n\nexport interface Leg {\n  id: string;\n  type: LegType;\n  text: string;\n  remark?: string;\n  startTime: Date;\n  endTime: Date;\n  startStopId: string;\n  endStopId: string;\n  trip?: Trip;\n  next: Leg[];\n}\n\ntype LegRelationMap = { [id: string]: Set<string> };\n\nexport interface MultilegResult {\n  legs: Leg[];\n  legPredecessors: LegRelationMap;\n  legSuccessors: LegRelationMap;\n}\n\nexport class MultilegMachine {\n  private readonly driveTimes: InterstopMap;\n  private readonly gtfsData: GTFSData;\n  private readonly driveMultipliers: number[];\n  private readonly disembarkTimeMin: number;\n  private readonly maxFerryOptions: number = 5;\n\n  constructor(\n    gtfsData: GTFSData,\n    driveTimes: InterstopMap,\n    driveMultipliers: number[],\n    disembarkTimeMin: number = 0\n  ) {\n    this.gtfsData = gtfsData;\n    this.driveTimes = driveTimes;\n    this.driveMultipliers = driveMultipliers;\n    this.disembarkTimeMin = disembarkTimeMin;\n  }\n\n  private describeTrip(stopId1: string, stopId2: string) {\n    const stop1 = this.gtfsData.stopMap[stopId1];\n    const stop2 = this.gtfsData.stopMap[stopId2];\n    return `${stop1.stop_name} -> ${stop2.stop_name}`;\n  }\n\n  private computeMultilegBitRecur(startTime: Date, legs: Readonly<LegFromToList>): Leg[] {\n    if (!legs.length) {\n      return [];\n    }\n    const [leg, ...nextLegs] = legs;\n    const [stopId1, stopId2] = leg;\n    const stop1 = this.gtfsData.stopMap[stopId1];\n    const stop2 = this.gtfsData.stopMap[stopId2];\n    if (!stop1) {\n      throw new Error(`missing stop 1: ${stopId1}`);\n    }\n    if (!stop2) {\n      throw new Error(`missing stop 2: ${stopId2}`);\n    }\n\n    const ferryNext = this._findFerry(startTime, stopId1, stopId2, nextLegs);\n    if (ferryNext !== undefined) return ferryNext;\n    const driveNext = this._findDrive(startTime, stopId1, stopId2, nextLegs);\n    if (driveNext !== undefined) return driveNext;\n\n\n    return [\n      {\n        id: `${stopId1}-${stopId2}-${+startTime}-error`,\n        type: LegType.ERROR,\n        text: `no valid route: ${this.describeTrip(stopId1, stopId2)}`,\n        startTime,\n        endTime: startTime,\n        startStopId: stopId1,\n        endStopId: stopId2,\n        next: [],\n      },\n    ];\n  }\n\n  private _findFerry(startTime: Date, stopId1: string, stopId2: string, nextLegs: Readonly<LegFromToList>): Leg[] | undefined {\n    const ferryTrips = computeSingleLeg(\n      this.gtfsData,\n      startTime,\n      stopId1,\n      stopId2\n    ).slice(0, this.maxFerryOptions);\n\n    if (!ferryTrips.length) {\n      return undefined;\n    }\n    return ferryTrips.map((trip) => {\n      const stops = this.gtfsData.tripStopSequences[trip.trip_id];\n      // TODO: does not take day-wrapping into account\n      const [dh, dm, ds] = hmsStringToTriple(stops[0].departure_time);\n      const [ah, am, as] = hmsStringToTriple(stops[1].arrival_time);\n      const tripStart = datefns.set(startTime, {\n        hours: dh,\n        minutes: dm,\n        seconds: ds,\n      });\n      const tripEnd = datefns.add(\n        datefns.set(startTime, {hours: ah, minutes: am, seconds: as}),\n        {minutes: this.disembarkTimeMin}\n      );\n      return {\n        id: `${trip.trip_id}`,\n        type: LegType.FERRY,\n        text: trip.trip_headsign,\n        startTime: tripStart,\n        endTime: tripEnd,\n        startStopId: stopId1,\n        endStopId: stopId2,\n        next: this.computeMultilegBitRecur(tripEnd, nextLegs),\n      };\n    });\n  }\n\n  private _findDrive(startTime: Date, stopId1: string, stopId2: string, nextLegs: Readonly<LegFromToList>): Leg[] | undefined {\n    const stopsKey = `${stopId1},${stopId2}`;\n    if (!this.driveTimes[stopsKey]) {\n      return undefined;\n    }\n    const multipliers = nextLegs.length > 0 ? this.driveMultipliers : [1];\n    return multipliers.map((mul) => {\n      const minutes = this.driveTimes[stopsKey] * mul;\n      const endTime = datefns.add(startTime, {minutes});\n      const leg: Leg = {\n        id: `${stopId1}-${stopId2}-${+startTime}-${+endTime}`,\n        type: LegType.DRIVE,\n        text: this.describeTrip(stopId1, stopId2),\n        remark:\n          mul !== 1 ? `${mul.toFixed(1)}x traffic adjustment` : undefined,\n        startTime,\n        endTime,\n        startStopId: stopId1,\n        endStopId: stopId2,\n        next: this.computeMultilegBitRecur(endTime, nextLegs),\n      };\n      return leg;\n    });\n  }\n\n  public computeMultileg(startTime: Date, stopIds: string[]): MultilegResult {\n    const legs = this.computeMultilegBitRecur(\n      startTime,\n      stopSequenceToLegs(stopIds)\n    );\n    const legSuccessors: LegRelationMap = {};\n    const legPredecessors: LegRelationMap = {};\n\n    function walk(leg: Leg, previous: Array<Leg> = []) {\n      const thisLegPredecessors = (legPredecessors[leg.id] =\n        legPredecessors[leg.id] || new Set());\n      previous.forEach((pleg) => thisLegPredecessors.add(pleg.id));\n      leg.next.forEach((nleg) => walk(nleg, [...previous, leg]));\n    }\n\n    legs.forEach((leg) => walk(leg));\n    Object.keys(legPredecessors).forEach((legId) => {\n      legPredecessors[legId].forEach((plegId) => {\n        const thisLegSuccessors = (legSuccessors[plegId] =\n          legSuccessors[plegId] || new Set());\n        thisLegSuccessors.add(legId);\n      });\n    });\n    return {legs, legSuccessors, legPredecessors};\n  }\n}\n","import { GTFSData, Trip } from \"./types\";\nimport { getValidServiceIdsForTime } from \"./utils\";\n\nexport function getValidTripsForStopPair(\n  gtfsData: GTFSData,\n  t: Date,\n  startStopId: string,\n  endStopId: string\n) {\n  const { tripStopFromToMap } = gtfsData;\n  const possibleTripIds = Array.from(\n    tripStopFromToMap[`${startStopId},${endStopId}`] || []\n  );\n  const availableServiceIds = getValidServiceIdsForTime(gtfsData, t);\n  const possibleTripServiceIds = new Set();\n  possibleTripIds.forEach((tripId) =>\n    possibleTripServiceIds.add(gtfsData.tripMap[tripId].service_id)\n  );\n  const validTrips = possibleTripIds\n    .map((tripId, index) => {\n      const trip = gtfsData.tripMap[tripId];\n      return trip && availableServiceIds.has(trip.service_id)\n        ? trip\n        : undefined;\n    })\n    .filter(Boolean) as Trip[];\n  // console.group(`${startStopId} -> ${endStopId} at ${t}`);\n  // console.log('possible trips', possibleTripIds.length);\n  // console.log('possible trips services', possibleTripServiceIds);\n  // console.log('available services', availableServiceIds);\n  // console.log('resulting valid trips', validTrips.length);\n  // console.groupEnd();\n  return validTrips;\n}\n","import { Leg, LegType } from \"../lib/multileg\";\nimport * as datefns from \"date-fns\";\nimport cx from \"classnames\";\nimport React from \"react\";\nimport { ViewProps } from \"./types\";\nimport { HTMLTable } from \"@blueprintjs/core\";\n\ninterface MultilegTableRowProps extends ViewProps {\n  leg: Leg;\n  parentLeg?: Leg;\n  depth: number;\n  accumulatedDuration?: number;\n  accumulatedWait?: number;\n}\n\nfunction getLegTypeLogo(leg: Leg): string {\n  switch (leg.type) {\n    case LegType.ERROR:\n      return \"‚ö°\";\n    case LegType.DRIVE:\n      return \"üöó\";\n    case LegType.FERRY:\n      return \"üö§\";\n    case LegType.WAIT:\n      return \"‚è≥\";\n  }\n  return \"???\";\n}\n\nfunction MultilegTableRow(props: MultilegTableRowProps) {\n  const {\n    leg,\n    parentLeg,\n    depth,\n    accumulatedDuration,\n    accumulatedWait,\n    result,\n    highlight,\n    setHighlight,\n  } = props;\n  const typeLogo = getLegTypeLogo(leg);\n  const wait = parentLeg\n    ? datefns.differenceInMinutes(leg.startTime, parentLeg.endTime)\n    : undefined;\n  const legDuration = datefns.differenceInMinutes(leg.endTime, leg.startTime);\n  const newAccumulatedDuration = (accumulatedDuration || 0) + legDuration;\n  const newAccumulatedWait = (accumulatedWait || 0) + (wait || 0);\n  let final = leg.next.length === 0;\n  let initial = depth === 0;\n  const classes: { [key: string]: boolean } = { initial, final };\n  if (\n    highlight &&\n    !(highlight === leg.id || result.legPredecessors[leg.id].has(highlight))\n  ) {\n    classes.faded = true;\n  }\n  if (highlight === leg.id) {\n    classes.highlight = true;\n  }\n\n  return (\n    <>\n      <tr\n        className={cx(classes)}\n        onClick={() => setHighlight(highlight === leg.id ? undefined : leg.id)}\n      >\n        <td className=\"dt st\">{datefns.format(leg.startTime, \"HH:mm\")}</td>\n        <td className=\"dt et\">{datefns.format(leg.endTime, \"HH:mm\")}</td>\n        <td className=\"dt du\">{legDuration} min</td>\n        <td className=\"dt wt\">\n          {wait !== undefined && wait > 0 ? `${wait} min` : null}\n        </td>\n        <td className=\"tl\">{typeLogo}</td>\n        <td className=\"tx\">\n          <div style={{ paddingLeft: `${depth}em` }}>\n            {leg.text}\n            <span className=\"remark\">{leg.remark}</span>\n          </div>\n        </td>\n        <td className=\"dt adu\">\n          <>{newAccumulatedDuration} + {newAccumulatedWait} wait = {newAccumulatedDuration + newAccumulatedWait} min</>\n        </td>\n      </tr>\n      {leg.next.map((childLeg, i) => (\n        <MultilegTableRow\n          {...props}\n          leg={childLeg}\n          parentLeg={leg}\n          key={i}\n          depth={depth + 1}\n          accumulatedDuration={newAccumulatedDuration}\n          accumulatedWait={newAccumulatedWait}\n        />\n      ))}\n    </>\n  );\n}\n\nexport function MultilegTable(props: ViewProps) {\n  return (\n    <HTMLTable id=\"t\" interactive>\n      <thead>\n        <tr>\n          <th>Start</th>\n          <th>End</th>\n          <th>Dur</th>\n          <th>Wait</th>\n          <th>Type</th>\n          <th>Description</th>\n          <th>Total Dur</th>\n        </tr>\n      </thead>\n      <tbody>\n        {props.result.legs.map((leg, i) => (\n          <MultilegTableRow {...props} leg={leg} key={i} depth={0} />\n        ))}\n      </tbody>\n    </HTMLTable>\n  );\n}\n","import {\n  Timeline as VisTimeline,\n  DataGroupCollectionType,\n  DataItemCollectionType,\n  TimelineOptions,\n} from \"vis-timeline\";\nimport \"vis-timeline/dist/vis-timeline-graph2d.min.css\";\nimport React from \"react\";\n\ntype VisEventCallback = (properties: any) => void;\n\nconst events = [\n  \"changed\",\n  \"click\",\n  \"contextmenu\",\n  \"currentTimeTick\",\n  \"doubleClick\",\n  \"drop\",\n  \"groupDragged\",\n  \"itemout\",\n  \"itemover\",\n  \"mouseDown\",\n  \"mouseMove\",\n  \"mouseOver\",\n  \"mouseUp\",\n  \"rangechange\",\n  \"rangechanged\",\n  \"select\",\n  \"timechange\",\n  \"timechanged\",\n];\n\ninterface TimelineProps {\n  options: TimelineOptions;\n  items: DataItemCollectionType;\n  groups?: DataGroupCollectionType;\n  eventHandlers?: { [key: string]: VisEventCallback };\n}\n\nconst Timeline: React.FC<TimelineProps> = ({\n  options,\n  items,\n  groups,\n  eventHandlers,\n}) => {\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const timelineRef = React.useRef<VisTimeline | null>(null);\n  const eventHandlersRef = React.useRef(eventHandlers);\n  React.useEffect(() => {\n    eventHandlersRef.current = eventHandlers;\n  }, [eventHandlers]);\n  const onEvent = React.useCallback((eventType, arg) => {\n    let handlers = eventHandlersRef.current;\n    if (handlers && eventType in handlers) {\n      handlers[eventType](arg);\n    }\n  }, []);\n  React.useEffect(() => {\n    if (containerRef.current) {\n      let timeline = timelineRef.current;\n      if (!timeline) {\n        timeline = new VisTimeline(containerRef.current, items, options);\n        events.forEach(\n          (eventType) =>\n            timeline && timeline.on(eventType, (arg) => onEvent(eventType, arg))\n        );\n        timelineRef.current = timeline;\n      } else {\n        timeline.setOptions(options);\n        timeline.setItems(items);\n      }\n      timeline.setGroups(groups);\n    }\n    return () => {\n      if (timelineRef.current) {\n        timelineRef.current.destroy();\n        timelineRef.current = null;\n      }\n    };\n  }, [onEvent, items, options, groups, containerRef]);\n  return <div ref={containerRef} />;\n};\n\nexport default Timeline;\n","import { Leg } from \"../lib/multileg\";\nimport Timeline from \"./ReactVisjsTimeline\";\nimport React from \"react\";\nimport { DataGroup, DataItem, TimelineOptions } from \"vis-timeline\";\nimport cx from \"classnames\";\nimport { ViewProps } from \"./types\";\n\nconst options: TimelineOptions = {\n  width: \"100%\",\n  stack: true,\n  showCurrentTime: true,\n  // zoomMin: 1000000,\n  // type: \"background\",\n  // format: {\n  //   minorLabels: {\n  //     minute: \"h:mma\",\n  //     hour: \"ha\",\n  //   },\n  // },\n};\n\nexport function MultilegTimeline({\n  gtfsData,\n  result,\n  highlight,\n  setHighlight,\n}: ViewProps) {\n  const { legs, legPredecessors } = result;\n  const [items, groups] = React.useMemo(() => {\n    const itemMap: { [id: string]: DataItem } = {};\n    const groupMap: { [id: string]: DataGroup } = {};\n    const itemClasses: { [id: string]: { [cls: string]: boolean } } = {};\n    const itemPredecessors: { [id: string]: Set<string> } = {};\n\n    function walk(leg: Leg, previous: Array<[Leg, string]>) {\n      const itemId = leg.id;\n      const groupId = `${leg.startStopId}-${leg.endStopId}`;\n      if (!(groupId in groupMap)) {\n        const endStopName = gtfsData.stopMap[leg.endStopId].stop_name;\n        groupMap[groupId] = {\n          id: groupId,\n          content: `${leg.type} to ${endStopName}`,\n        };\n      }\n      const classes = (itemClasses[itemId] = itemClasses[itemId] || {});\n      itemPredecessors[itemId] = legPredecessors[leg.id]; // just in case we accidentally alias item ids\n      classes[leg.type] = true;\n      if (!leg.next.length) {\n        classes.final = true;\n      }\n      if (!previous.length) {\n        classes.initial = true;\n      }\n      itemMap[itemId] = {\n        id: itemId,\n        group: groupId,\n        start: leg.startTime,\n        end: leg.endTime,\n        content: leg.text,\n      };\n      leg.next.forEach((l) => walk(l, [...previous, [leg, itemId]]));\n    }\n\n    legs.forEach((l) => walk(l, []));\n\n    if (highlight) {\n      for (let itemId in itemMap) {\n        if (itemId !== highlight && !itemPredecessors[itemId].has(highlight)) {\n          itemClasses[itemId].faded = true;\n        }\n      }\n    }\n    for (let itemId in itemClasses) {\n      if (itemMap[itemId]) {\n        itemMap[itemId].className = cx(itemClasses[itemId]);\n      }\n    }\n    return [[...Object.values(itemMap)], [...Object.values(groupMap)]];\n  }, [gtfsData.stopMap, legs, legPredecessors, highlight]);\n  const onSelect = ({ items }: { items: string }) => setHighlight(items[0]);\n  return (\n    <Timeline\n      options={options}\n      items={items}\n      groups={groups}\n      eventHandlers={{ select: onSelect }}\n    />\n  );\n}\n","import {InterstopMap} from \"./lib/multileg\";\nimport rawDriveTimeData from \"./data/drive-times.json\";\n\nexport const defaultRouteStopNames = [\n  \"Turku\",\n  \"Lillm√§l√∂\",\n  \"Prostvik\",\n  \"P√§rn√§s\",\n  \"Retais\",\n  \"Korppoo (keskusta)\",\n];\n\nexport const driveTravelTimes: InterstopMap = {};\n\ntype RawDriveTimeDatum = [string, string, number, number];\n\n(rawDriveTimeData as RawDriveTimeDatum[]).forEach(([s1, s2, duration]) => {\n  driveTravelTimes[`${s1},${s2}`] = duration;\n  driveTravelTimes[`${s2},${s1}`] = duration;\n});\n","import * as datefns from \"date-fns\";\nimport React from \"react\";\nimport { DateInput, IDateFormatProps, TimePicker } from \"@blueprintjs/datetime\";\n\nconst jsDateFormatter: IDateFormatProps = {\n  // note that the native implementation of Date functions differs between browsers\n  formatDate: (date) => datefns.format(date, \"yyyy-MM-dd\"),\n  parseDate: (str) => new Date(str),\n};\n\ntype TimeConfigProps = { date: Date; onChange: (date: Date) => void };\n\nexport function TimeConfig({ date, onChange }: TimeConfigProps) {\n  return (\n    <div style={{ display: \"flex\" }}>\n      <div style={{ flex: 1 }}>\n        <DateInput\n          {...jsDateFormatter}\n          showActionsBar\n          value={date}\n          onChange={(date, isUserChange) =>\n            isUserChange ? onChange(date) : null\n          }\n        />\n      </div>\n      <div style={{ flex: 1 }}>\n        <TimePicker value={date} onChange={onChange} />\n      </div>\n    </div>\n  );\n}\n","import { GTFSData } from \"../lib/gtfs/types\";\nimport { InterstopMap } from \"../lib/multileg\";\nimport React from \"react\";\nimport { getDestinationStopsFromStop } from \"../lib/gtfs/utils\";\nimport { reverse, sortBy } from \"lodash\";\nimport { Button, HTMLSelect, Tag } from \"@blueprintjs/core\";\n\ninterface RouteConfigProps {\n  stopIds: string[];\n  setStopIds: (stopIds: string[]) => void;\n  gtfsData: GTFSData;\n  driveTravelTimes: InterstopMap;\n}\n\nexport function RouteConfig({\n  stopIds,\n  setStopIds,\n  gtfsData,\n  driveTravelTimes,\n}: RouteConfigProps) {\n  const lastStopId = stopIds.length ? stopIds[stopIds.length - 1] : null;\n  const nextStops = getDestinationStopsFromStop(gtfsData, lastStopId);\n  if (lastStopId) {\n    Object.keys(driveTravelTimes).forEach((key) => {\n      const [fromStopId, toStopId] = key.split(\",\");\n      if (fromStopId === lastStopId) {\n        nextStops.add(toStopId);\n      }\n    });\n  }\n  const nextSelect = (\n    <HTMLSelect\n      disabled={!nextStops.size}\n      onChange={(e) => {\n        const selection = e.target.value;\n        if (nextStops.has(selection)) {\n          setStopIds(stopIds.concat([selection]));\n        }\n      }}\n    >\n      <option value=\"\">Add...</option>\n      {sortBy(\n        Array.from(nextStops).map((stopId) => [\n          stopId,\n          gtfsData.stopMap[stopId].stop_name,\n        ]),\n        1\n      ).map(([stopId, name]) => (\n        <option key={stopId} value={stopId}>\n          {name}\n        </option>\n      ))}\n    </HTMLSelect>\n  );\n  return (\n    <>\n      <div>\n        {stopIds.map((stopId, idx) => (\n          <Tag\n            key={idx}\n            large\n            onRemove={() => setStopIds(stopIds.filter((sid) => sid !== stopId))}\n            style={{ marginRight: \".5em\" }}\n          >\n            {gtfsData.stopMap[stopId].stop_name}\n          </Tag>\n        ))}\n      </div>\n      <div style={{ marginTop: \".5em\" }}>\n        {nextSelect}{\" \"}\n        <Button\n          icon=\"refresh\"\n          disabled={!stopIds.length}\n          onClick={() => setStopIds(reverse([...stopIds]))}\n        >\n          Reverse\n        </Button>{\" \"}\n        <Button\n          icon=\"delete\"\n          disabled={!stopIds.length}\n          onClick={() => setStopIds([])}\n        >\n          Clear\n        </Button>\n      </div>\n    </>\n  );\n}\n","import { Card, FormGroup, H5, Slider } from \"@blueprintjs/core\";\nimport { TimeConfig } from \"./TimeConfig\";\nimport { RouteConfig } from \"./RouteConfig\";\nimport { driveTravelTimes } from \"../tribalKnowledge\";\nimport React from \"react\";\nimport { GTFSData } from \"../lib/gtfs/types\";\n\ninterface ConfigSectionProps {\n  gtfsData: GTFSData;\n  date: Date;\n  onChangeDate: (value: Date) => void;\n  stopIds: string[];\n  setStopIds: (value: string[]) => void;\n  setDisembarkTimeMin: (value: number) => void;\n  disembarkTimeMin: number;\n  setDriveTimeMultiplier: (v: number) => void;\n  driveTimeMultiplier: number;\n}\n\nexport function ConfigSection(props: ConfigSectionProps) {\n  return (\n    <div style={{ display: \"flex\" }}>\n      <Card style={{ flex: 1, margin: \".5em\" }}>\n        <H5>Departure Time</H5>\n        <TimeConfig date={props.date} onChange={props.onChangeDate} />\n      </Card>\n      <Card style={{ flex: 3, margin: \".5em\" }}>\n        <H5>Route</H5>\n        <RouteConfig\n          stopIds={props.stopIds}\n          setStopIds={props.setStopIds}\n          gtfsData={props.gtfsData}\n          driveTravelTimes={driveTravelTimes}\n        />\n      </Card>\n      <Card style={{ flex: 1, margin: \".5em\" }}>\n        <H5>Options</H5>\n        <FormGroup label=\"Disembarkation time (min)\">\n          <Slider\n            min={0}\n            max={20}\n            stepSize={1}\n            labelStepSize={5}\n            onChange={props.setDisembarkTimeMin}\n            value={props.disembarkTimeMin}\n          />\n        </FormGroup>\n        <FormGroup label=\"Drive time multiplier\">\n          <Slider\n            min={0}\n            max={2}\n            stepSize={0.1}\n            labelStepSize={0.5}\n            onChange={props.setDriveTimeMultiplier}\n            value={props.driveTimeMultiplier}\n          />\n        </FormGroup>\n      </Card>\n    </div>\n  );\n}\n","import { Leg, LegType } from \"../lib/multileg\";\nimport cytoscape, { ElementDefinition } from \"cytoscape\";\nimport klay from \"cytoscape-klay\";\nimport CytoscapeComponent from \"react-cytoscapejs\";\n\nimport * as datefns from \"date-fns\";\nimport React from \"react\";\nimport { ViewProps } from \"./types\";\n\ncytoscape.use(klay);\n\nexport function MultilegGraph({ gtfsData, result }: ViewProps) {\n  const { legs } = result;\n  const nodes: { [id: string]: ElementDefinition } = {};\n  const edges: { [id: string]: ElementDefinition } = {};\n\n  function stopNode(stopId: string): string {\n    const id = `stop-${stopId}`;\n    if (!nodes[id]) {\n      const stop = gtfsData.stopMap[stopId];\n      nodes[id] = {\n        data: { id, label: stop.stop_name },\n      };\n    }\n    return id;\n  }\n\n  function walk(leg: Leg, previous: Array<[Leg, string, string]>) {\n    let startId = \"\",\n      endId = \"\";\n    if (!previous.length) {\n      startId = stopNode(leg.startStopId);\n    } else {\n      startId = previous[previous.length - 1][2];\n    }\n    if (false) {\n      //!leg.next.length) {\n      endId = stopNode(leg.endStopId);\n    } else {\n      endId = `${leg.endStopId}-${leg.endTime}`;\n      const stop = gtfsData.stopMap[leg.endStopId];\n      nodes[endId] = {\n        data: {\n          id: endId,\n          label: `${stop.stop_name} at ${datefns.format(leg.endTime, \"HH:mm\")}`,\n        },\n      };\n    }\n\n    const edgeId = `${startId}-${endId}-${leg.startTime}`;\n    const legDuration = datefns.differenceInMinutes(leg.endTime, leg.startTime);\n    const parentLeg = previous.length\n      ? previous[previous.length - 1][0]\n      : undefined;\n    const wait = parentLeg\n      ? datefns.differenceInMinutes(leg.startTime, parentLeg.endTime)\n      : undefined;\n    let edgeLabel =\n      (wait ? `${wait}min wait, ` : \"\") + `${legDuration}min ${leg.type}`;\n    edges[edgeId] = {\n      data: {\n        id: edgeId,\n        source: startId,\n        target: endId,\n        label: edgeLabel,\n      },\n      classes: `${leg.type}`,\n    };\n    leg.next.forEach((l) => walk(l, [...previous, [leg, startId, endId]]));\n  }\n\n  legs.forEach((l) => walk(l, []));\n\n  return (\n    <CytoscapeComponent\n      elements={[...Object.values(nodes), ...Object.values(edges)]}\n      stylesheet={[\n        {\n          selector: \"node\",\n          style: {\n            label: \"data(label)\",\n          },\n        },\n        {\n          selector: \"edge\",\n          style: {\n            label: \"data(label)\",\n            \"curve-style\": \"straight\",\n          },\n        },\n        {\n          selector: \"edge.ferry\",\n          style: {\n            \"line-color\": \"navy\",\n          },\n        },\n      ]}\n      layout={{\n        name: \"klay\",\n        nodeDimensionsIncludeLabels: true,\n        klay: {\n          direction: \"RIGHT\",\n          edgeRouting: \"SPLINES\",\n        },\n      }}\n      style={{ width: \"100%\", height: \"600px\", border: \"1px solid orange\" }}\n    />\n  );\n}\n","import papaparse from \"papaparse\";\nimport { GTFSData, RawGTFSData } from \"./types\";\nimport { groupBy, keyBy } from \"lodash\";\nimport { getTripStopFromToMap } from \"./utils\";\nimport formatDate from \"date-fns/format\";\n\nexport async function parseMultipleUrls<T extends object>(urlMap: {\n  [key: string]: string;\n}): Promise<T> {\n  const promises = Object.keys(urlMap).map(async (key) => {\n    const resp = await fetch(urlMap[key]);\n    if (!resp.ok) throw new Error(resp.statusText);\n    const text = (await resp.text()).replace(/[\\r\\n]+/g, \"\\n\").trim();\n    const result = papaparse.parse(text, {\n      header: true,\n    });\n    if (result.errors?.length) console.warn(key, result.errors);\n    return [key, result.data];\n  });\n  const results = await Promise.all(promises);\n  return Object.fromEntries(results);\n}\n\nexport function filterRawGTFSData(rawData: RawGTFSData, dateCutoff: Date) {\n  const dateCutoffYMD = formatDate(dateCutoff, \"yyyyMMdd\");\n  rawData.calendarDates = rawData.calendarDates.filter(\n    (cd) => cd.date >= dateCutoffYMD\n  );\n  rawData.calendar = rawData.calendar.filter(\n    (ce) => ce.end_date >= dateCutoffYMD\n  );\n}\n\nexport function augmentRawGTFSData(rawData: RawGTFSData): GTFSData {\n  const tripStopSequences = groupBy(rawData.stopTimes, (st) => st.trip_id);\n  const tripStopFromToMap = getTripStopFromToMap(tripStopSequences);\n  return {\n    ...rawData,\n    routeMap: keyBy(rawData.routes, \"route_id\"),\n    stopMap: keyBy(rawData.stops, \"stop_id\"),\n    tripMap: keyBy(rawData.trips, \"trip_id\"),\n    tripStopSequences,\n    tripStopFromToMap,\n  };\n}\n","import { GTFSData, RawGTFSData } from \"./lib/gtfs/types\";\nimport {\n  augmentRawGTFSData,\n  filterRawGTFSData,\n  parseMultipleUrls,\n} from \"./lib/gtfs/parse\";\n\nfunction filterAndAugmentRawData(\n  rawData: RawGTFSData,\n  cutoffDate?: Date\n): GTFSData {\n  if (cutoffDate) {\n    filterRawGTFSData(rawData, cutoffDate);\n  }\n  return augmentRawGTFSData(rawData);\n}\n\nfunction loadRawDataRequire(): Promise<RawGTFSData> {\n  return parseMultipleUrls<RawGTFSData>({\n    agency: require(\"./data/gtfs/agency.txt\"),\n    calendar: require(\"./data/gtfs/calendar.txt\"),\n    calendarDates: require(\"./data/gtfs/calendar_dates.txt\"),\n    frequencies: require(\"./data/gtfs/frequencies.txt\"),\n    routes: require(\"./data/gtfs/routes.txt\"),\n    stopTimes: require(\"./data/gtfs/stop_times.txt\"),\n    stops: require(\"./data/gtfs/stops.txt\"),\n    trips: require(\"./data/gtfs/trips.txt\"),\n  });\n}\n\nexport async function getFilteredGTFSData() {\n  const rawData = await loadRawDataRequire();\n  return filterAndAugmentRawData(rawData, new Date(2020, 0));\n}\n","import React from \"react\";\nimport { GTFSData } from \"./lib/gtfs/types\";\nimport { MultilegMachine } from \"./lib/multileg\";\nimport * as datefns from \"date-fns\";\nimport { MultilegTable } from \"./components/MultilegTable\";\nimport { MultilegTimeline } from \"./components/MultilegTimeline\";\nimport {defaultRouteStopNames, driveTravelTimes} from \"./tribalKnowledge\";\nimport { Button, NonIdealState, Tab, Tabs } from \"@blueprintjs/core\";\nimport { uniq } from \"lodash\";\nimport { ConfigSection } from \"./components/ConfigSection\";\nimport { MultilegGraph } from \"./components/MultilegGraph\";\nimport { ViewProps } from \"./components/types\";\nimport { getFilteredGTFSData } from \"./app-data\";\n\nfunction App() {\n  const [gtfsData, setGtfsData] = React.useState<GTFSData | undefined>();\n  React.useEffect(() => {\n    getFilteredGTFSData().then(setGtfsData);\n  }, []);\n\n  if (gtfsData === undefined) return null;\n  return <Core gtfsData={gtfsData} />;\n}\n\nfunction ResultTabs(props: {\n  id: string;\n  viewProps: ViewProps;\n  renderButton?: boolean;\n  buttonActive?: boolean;\n  onButtonClick?: () => void;\n}) {\n  return (\n    <Tabs id={props.id} renderActiveTabPanelOnly>\n      <Tab\n        id=\"timeline\"\n        title=\"Timeline\"\n        panel={<MultilegTimeline {...props.viewProps} />}\n      />\n      <Tab\n        id=\"table\"\n        title=\"Table\"\n        panel={<MultilegTable {...props.viewProps} />}\n      />\n      <Tab\n        id=\"graph\"\n        title=\"Graph\"\n        panel={<MultilegGraph {...props.viewProps} />}\n      />\n      {props.renderButton ? (\n        <>\n          <Tabs.Expander />\n          <Button\n            icon=\"split-columns\"\n            active={props.buttonActive}\n            onClick={props.onButtonClick}\n          >\n            Split\n          </Button>\n        </>\n      ) : null}\n    </Tabs>\n  );\n}\n\nfunction Core({ gtfsData }: { gtfsData: GTFSData }) {\n  const [highlight, setHighlight] = React.useState<string | undefined>();\n  const [startTime, setStartTime] = React.useState(() => new Date()); //new Date(2020, 3, 13, 12, 10, 0));\n  const [stopIds, setStopIds] = React.useState<string[]>(() => {\n    return defaultRouteStopNames.map(name => {\n      const stop = gtfsData.stops.find(stop => stop.stop_name.startsWith(name));\n      return (stop ? stop.stop_id : '');\n    });\n  });\n  const [disembarkTimeMin, setDisembarkTimeMin] = React.useState(3);\n  const [driveTimeMultiplier, setDriveTimeMultiplier] = React.useState(1.5);\n  const [splitEnabled, setSplitEnabled] = React.useState(false);\n  const mlm = React.useMemo(\n    () =>\n      new MultilegMachine(\n        gtfsData,\n        driveTravelTimes,\n        uniq([1, driveTimeMultiplier]),\n        disembarkTimeMin\n      ),\n    [gtfsData, disembarkTimeMin, driveTimeMultiplier]\n  );\n  const result = React.useMemo(() => mlm.computeMultileg(startTime, stopIds), [\n    mlm,\n    startTime,\n    stopIds,\n  ]);\n  const viewProps: ViewProps = { gtfsData, result, highlight, setHighlight };\n  const resultView = result.legs.length ? (\n    <>\n      <h1>\n        {datefns.format(startTime, \"dd.MM.yyyy HH:mm\")}\n        <br />\n        {stopIds\n          .map((stopId) => gtfsData.stopMap[stopId])\n          .map((s) => s.stop_name)\n          .join(\" - \")}\n      </h1>\n      <div style={{ display: \"flex\" }}>\n        <div style={{ flex: 1 }}>\n          <ResultTabs\n            id=\"tabs1\"\n            viewProps={viewProps}\n            renderButton\n            buttonActive={splitEnabled}\n            onButtonClick={() => setSplitEnabled(!splitEnabled)}\n          />\n        </div>\n\n        {splitEnabled ? (\n          <div style={{ flex: 1 }}>\n            <ResultTabs id=\"tabs2\" viewProps={viewProps} />\n          </div>\n        ) : null}\n      </div>\n    </>\n  ) : (\n    <NonIdealState icon=\"search\" title=\"No results\" />\n  );\n  return (\n    <div className=\"App\">\n      <ConfigSection\n        date={startTime}\n        onChangeDate={setStartTime}\n        stopIds={stopIds}\n        setStopIds={setStopIds}\n        gtfsData={gtfsData}\n        setDisembarkTimeMin={setDisembarkTimeMin}\n        disembarkTimeMin={disembarkTimeMin}\n        setDriveTimeMultiplier={(v) =>\n          setDriveTimeMultiplier(parseFloat(v.toFixed(2)))\n        }\n        driveTimeMultiplier={driveTimeMultiplier}\n      />\n      {resultView}\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport \"normalize.css\";\nimport \"@blueprintjs/core/lib/css/blueprint.css\";\nimport \"@blueprintjs/datetime/lib/css/blueprint-datetime.css\";\nimport \"@blueprintjs/icons/lib/css/blueprint-icons.css\";\n\nimport App from \"./App\";\n//import * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// serviceWorker.register();\n"],"sourceRoot":""}