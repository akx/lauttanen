{"version":3,"sources":["data/gtfs/agency.txt","data/gtfs/calendar.txt","data/gtfs/calendar_dates.txt","data/gtfs/frequencies.txt","data/gtfs/routes.txt","data/gtfs/stop_times.txt","data/gtfs/stops.txt","data/gtfs/trips.txt","lib/gtfs/utils.ts","lib/set-utils.ts","lib/gtfs/parse.ts","lib/time.ts","lib/multileg.ts","lib/gtfs/trips.ts","components/MultilegTable.tsx","components/ReactVisjsTimeline.tsx","components/MultilegTimeline.tsx","tribalKnowledge.tsx","components/TimeConfig.tsx","components/RouteConfig.tsx","components/ConfigSection.tsx","components/MultilegGraph.tsx","App.tsx","index.tsx"],"names":["module","exports","getValidServiceIdsForTime","gtfsData","t","dateYMD","formatDate","weekday","getUTCDay","calendarServiceIds","calendar","filter","ce","dateValid","start_date","end_date","weekdayValid","sunday","monday","tuesday","wednesday","thursday","friday","saturday","map","service_id","addServiceIds","calendarDates","cd","date","exception_type","delServiceIds","set1","sOut","Set","sets","forEach","set","v","delete","intersect","add","union","parseMultipleUrls","urlMap","a","promises","Object","keys","key","fetch","resp","ok","Error","statusText","text","replace","trim","result","papaparse","parse","header","errors","length","console","warn","data","Promise","all","results","fromEntries","filterRawGTFSData","rawData","dateCutoff","dateCutoffYMD","augmentRawGTFSData","tripStopSequences","groupBy","stopTimes","st","trip_id","tripStopFromToMap","tripId","stops","fromStop","toStop","stop_id","getTripStopFromToMap","routeMap","keyBy","routes","stopMap","tripMap","trips","hmsToDaySeconds","h","m","s","hmsStringToTriple","hmsString","split","bit","parseInt","LegType","computeSingleLeg","startTime","startStopId","endStopId","possibleTripIds","Array","from","availableServiceIds","possibleTripServiceIds","index","trip","has","undefined","Boolean","getValidTripsForStopPair","startTimeDS","getHours","getMinutes","getSeconds","hmsStringToDaySeconds","departure_time","MultilegMachine","interStopTravelMap","driveMultipliers","disembarkTimeMin","maxFerryOptions","this","legs","leg","nextLegs","stopId1","stopId2","stopsKey","stop1","stop2","mul","minutes","endTime","datefns","id","type","DRIVE","stop_name","remark","toFixed","next","computeMultilegBitRecur","slice","dh","dm","ds","arrival_time","ah","am","as","tripStart","hours","seconds","tripEnd","FERRY","trip_headsign","ERROR","stopIds","i","push","stopSequenceToLegs","legSuccessors","legPredecessors","walk","previous","thisLegPredecessors","pleg","nleg","legId","plegId","MultilegTableRow","props","parentLeg","depth","accumulatedDuration","highlight","setHighlight","typeLogo","WAIT","getLegTypeLogo","wait","legDuration","newAccumulatedDuration","final","classes","initial","faded","className","cx","onClick","style","paddingLeft","childLeg","MultilegTable","interactive","events","Timeline","options","items","groups","eventHandlers","containerRef","React","useRef","timelineRef","eventHandlersRef","useEffect","current","onEvent","useCallback","eventType","arg","handlers","timeline","setOptions","setItems","VisTimeline","on","setGroups","destroy","ref","width","stack","showCurrentTime","MultilegTimeline","useMemo","itemMap","groupMap","itemClasses","itemPredecessors","l","itemId","groupId","endStopName","content","group","start","end","values","select","defaultRoute","driveTravelTimes","pair","duration","s1","s2","jsDateFormatter","parseDate","str","Date","TimeConfig","onChange","display","flex","showActionsBar","value","isUserChange","RouteConfig","setStopIds","lastStopId","nextStops","stopId","destSet","getDestinationStopsFromStop","fromStopId","toStopId","nextSelect","disabled","size","e","selection","target","concat","sortBy","name","idx","large","onRemove","sid","marginRight","marginTop","icon","reverse","ConfigSection","margin","onChangeDate","label","min","max","stepSize","labelStepSize","setDisembarkTimeMin","setDriveTimeMultiplier","driveTimeMultiplier","MultilegGraph","nodes","edges","startId","endId","stop","stopNode","edgeId","edgeLabel","source","elements","stylesheet","selector","layout","nodeDimensionsIncludeLabels","klay","direction","edgeRouting","height","border","cutoffDate","agency","require","frequencies","ResultTabs","renderActiveTabPanelOnly","title","panel","viewProps","renderButton","Expander","active","buttonActive","onButtonClick","Core","useState","setStartTime","splitEnabled","setSplitEnabled","mlm","uniq","computeMultileg","resultView","join","parseFloat","cytoscape","use","App","setGtfsData","getGTFSData","then","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.5c2db9ad.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/agency.d9438b70.txt\";","module.exports = __webpack_public_path__ + \"static/media/calendar.7f329882.txt\";","module.exports = __webpack_public_path__ + \"static/media/calendar_dates.9aefd69f.txt\";","module.exports = __webpack_public_path__ + \"static/media/frequencies.16dfdd58.txt\";","module.exports = __webpack_public_path__ + \"static/media/routes.20f1bb24.txt\";","module.exports = __webpack_public_path__ + \"static/media/stop_times.2a09dc52.txt\";","module.exports = __webpack_public_path__ + \"static/media/stops.013405fc.txt\";","module.exports = __webpack_public_path__ + \"static/media/trips.a34aa8ef.txt\";","import { FromToTripMap, GTFSData, StopTime } from \"./types\";\nimport formatDate from \"date-fns/format\";\nimport { intersect, union } from \"../set-utils\";\nimport { Dictionary } from \"lodash\";\n\nexport function getTripStopFromToMap(\n  tripStopSequences: Dictionary<StopTime[]>\n): FromToTripMap {\n  const tripStopFromToMap: FromToTripMap = {};\n  for (let tripId in tripStopSequences) {\n    const stops = tripStopSequences[tripId];\n    if (stops.length !== 2) {\n      // TODO: support trips with more than 2 stops?\n      //console.warn(`trip ${tripId} has more than 2 stops?`, stops);\n      continue;\n    }\n    const [fromStop, toStop] = stops;\n    const key = `${fromStop.stop_id},${toStop.stop_id}`;\n    if (!tripStopFromToMap[key]) {\n      tripStopFromToMap[key] = new Set();\n    }\n    tripStopFromToMap[key].add(tripId);\n  }\n  return tripStopFromToMap;\n}\n\nexport function getDestinationStopsFromStop(\n  gtfsData: GTFSData,\n  stopId: string | null\n): Set<string> {\n  const destSet = new Set<string>();\n  for (let tripId in gtfsData.tripStopSequences) {\n    const stops = gtfsData.tripStopSequences[tripId];\n    if (stops.length !== 2) {\n      // TODO: support trips with more than 2 stops?\n      continue;\n    }\n    const [fromStop, toStop] = stops;\n    if (stopId === null) {\n      // If no stop was defined, get all the initial stops we\n      // know have outward routes.\n      destSet.add(fromStop.stop_id);\n    } else if (fromStop.stop_id === stopId) {\n      destSet.add(toStop.stop_id);\n    }\n  }\n  return destSet;\n}\n\nexport function getValidServiceIdsForTime(gtfsData: GTFSData, t: Date) {\n  const dateYMD = formatDate(t, \"yyyyMMdd\");\n  const weekday = t.getUTCDay(); // 0 = sunday\n  const calendarServiceIds = gtfsData.calendar\n    .filter((ce) => {\n      // console.log(ce.service_id, dateYMD, ce.start_date, ce.end_date);\n      const dateValid = ce.start_date <= dateYMD && dateYMD <= ce.end_date;\n      const weekdayValid =\n        (weekday === 0 && ce.sunday === \"1\") ||\n        (weekday === 1 && ce.monday === \"1\") ||\n        (weekday === 2 && ce.tuesday === \"1\") ||\n        (weekday === 3 && ce.wednesday === \"1\") ||\n        (weekday === 4 && ce.thursday === \"1\") ||\n        (weekday === 5 && ce.friday === \"1\") ||\n        (weekday === 6 && ce.saturday === \"1\");\n      return dateValid && weekdayValid;\n    })\n    .map((ce) => ce.service_id);\n  // 1 - Service has been added for the specified date.\n  // 2 - Service has been removed for the specified date.\n  const addServiceIds = gtfsData.calendarDates\n    .filter((cd) => cd.date === dateYMD && cd.exception_type === \"1\")\n    .map((cd) => cd.service_id);\n  const delServiceIds = gtfsData.calendarDates\n    .filter((cd) => cd.date === dateYMD && cd.exception_type === \"2\")\n    .map((cd) => cd.service_id);\n  //console.log(t, \"si\", calendarServiceIds, addServiceIds, delServiceIds);\n  return intersect(\n    union(new Set(calendarServiceIds), new Set(addServiceIds)),\n    new Set(delServiceIds)\n  );\n}\n","export function union<T>(...sets: Set<T>[]): Set<T> {\n  const sOut = new Set<T>();\n  sets.forEach((set) => set.forEach((v) => sOut.add(v)));\n  return sOut;\n}\n\nexport function intersect<T>(set1: Set<T>, ...sets: Set<T>[]): Set<T> {\n  const sOut = new Set<T>(set1);\n  sets.forEach((set) => set.forEach((v) => sOut.delete(v)));\n  return sOut;\n}\n","import papaparse from \"papaparse\";\nimport { GTFSData, RawGTFSData } from \"./types\";\nimport { groupBy, keyBy } from \"lodash\";\nimport { getTripStopFromToMap } from \"./utils\";\nimport formatDate from \"date-fns/format\";\n\nexport async function parseMultipleUrls<T extends object>(urlMap: {\n  [key: string]: string;\n}): Promise<T> {\n  const promises = Object.keys(urlMap).map(async (key) => {\n    const resp = await fetch(urlMap[key]);\n    if (!resp.ok) throw new Error(resp.statusText);\n    const text = (await resp.text()).replace(/[\\r\\n]+/g, \"\\n\").trim();\n    const result = papaparse.parse(text, {\n      header: true,\n    });\n    if (result.errors?.length) console.warn(key, result.errors);\n    return [key, result.data];\n  });\n  const results = await Promise.all(promises);\n  return Object.fromEntries(results);\n}\n\nexport function filterRawGTFSData(rawData: RawGTFSData, dateCutoff: Date) {\n  const dateCutoffYMD = formatDate(dateCutoff, \"yyyyMMdd\");\n  rawData.calendarDates = rawData.calendarDates.filter(\n    (cd) => cd.date >= dateCutoffYMD\n  );\n  rawData.calendar = rawData.calendar.filter(\n    (ce) => ce.end_date >= dateCutoffYMD\n  );\n}\n\nexport function augmentRawGTFSData(rawData: RawGTFSData): GTFSData {\n  const tripStopSequences = groupBy(rawData.stopTimes, (st) => st.trip_id);\n  const tripStopFromToMap = getTripStopFromToMap(tripStopSequences);\n  return {\n    ...rawData,\n    routeMap: keyBy(rawData.routes, \"route_id\"),\n    stopMap: keyBy(rawData.stops, \"stop_id\"),\n    tripMap: keyBy(rawData.trips, \"trip_id\"),\n    tripStopSequences,\n    tripStopFromToMap,\n  };\n}\n","export function hmsToDaySeconds(h: number, m: number, s: number): number {\n  return h * 60 * 60 + m * 60 + s;\n}\n\nexport function hmsStringToTriple(hmsString: string): [number, number, number] {\n  const [h, m, s] = hmsString.split(\":\").map((bit) => parseInt(bit, 10));\n  return [h, m, s];\n}\n\nexport function hmsStringToDaySeconds(hmsString: string): number {\n  const [h, m, s] = hmsStringToTriple(hmsString);\n  return hmsToDaySeconds(h, m, s);\n}\n\nexport function dateToDaySeconds(date: Date): number {\n  const h = date.getHours();\n  const m = date.getMinutes();\n  const s = date.getSeconds();\n  return hmsToDaySeconds(h, m, s);\n}\n","import { GTFSData, Trip } from \"./gtfs/types\";\nimport { getValidTripsForStopPair } from \"./gtfs/trips\";\nimport {\n  dateToDaySeconds,\n  hmsStringToDaySeconds,\n  hmsStringToTriple,\n} from \"./time\";\nimport * as datefns from \"date-fns\";\n\nexport type InterstopMap = { [pair: string]: number };\n\nexport function computeSingleLeg(\n  gtfsData: GTFSData,\n  startTime: Date,\n  startStopId: string,\n  endStopId: string\n): Trip[] {\n  const trips = getValidTripsForStopPair(\n    gtfsData,\n    startTime,\n    startStopId,\n    endStopId\n  );\n  const startTimeDS = dateToDaySeconds(startTime);\n  return trips.filter((t) => {\n    const stops = gtfsData.tripStopSequences[t.trip_id];\n    return hmsStringToDaySeconds(stops[0].departure_time) >= startTimeDS;\n  });\n}\n\ntype LegList = Array<[string, string]>;\n\nfunction stopSequenceToLegs(stopIds: string[]): LegList {\n  const legs: LegList = [];\n  for (var i = 1; i < stopIds.length; i++) {\n    legs.push([stopIds[i - 1], stopIds[i]]);\n  }\n  return legs;\n}\n\nexport enum LegType {\n  ERROR = \"error\",\n  WAIT = \"wait\",\n  DRIVE = \"drive\",\n  FERRY = \"ferry\",\n}\n\nexport interface Leg {\n  id: string;\n  type: LegType;\n  text: string;\n  remark?: string;\n  startTime: Date;\n  endTime: Date;\n  startStopId: string;\n  endStopId: string;\n  trip?: Trip;\n  next: Leg[];\n}\n\ntype LegRelationMap = { [id: string]: Set<string> };\n\nexport interface MultilegResult {\n  legs: Leg[];\n  legPredecessors: LegRelationMap;\n  legSuccessors: LegRelationMap;\n}\n\nexport class MultilegMachine {\n  private readonly interStopTravelMap: InterstopMap;\n  private readonly gtfsData: GTFSData;\n  private readonly driveMultipliers: number[];\n  private readonly disembarkTimeMin: number;\n  private readonly maxFerryOptions: number = 5;\n\n  constructor(\n    gtfsData: GTFSData,\n    interStopTravelMap: InterstopMap,\n    driveMultipliers: number[],\n    disembarkTimeMin: number = 0\n  ) {\n    this.gtfsData = gtfsData;\n    this.interStopTravelMap = interStopTravelMap;\n    this.driveMultipliers = driveMultipliers;\n    this.disembarkTimeMin = disembarkTimeMin;\n  }\n\n  private computeMultilegBitRecur(startTime: Date, legs: LegList): Leg[] {\n    if (!legs.length) {\n      return [];\n    }\n    const [leg, ...nextLegs] = legs;\n    const [stopId1, stopId2] = leg;\n    const stopsKey = `${stopId1},${stopId2}`;\n    const stop1 = this.gtfsData.stopMap[stopId1];\n    const stop2 = this.gtfsData.stopMap[stopId2];\n    if (this.interStopTravelMap[stopsKey]) {\n      let multipliers = nextLegs.length > 0 ? this.driveMultipliers : [1];\n      return multipliers.map((mul) => {\n        const minutes = this.interStopTravelMap[stopsKey] * mul;\n        const endTime = datefns.add(startTime, { minutes });\n        return {\n          id: `${stopId1}-${stopId2}-${+startTime}-${+endTime}`,\n          type: LegType.DRIVE,\n          text: `${stop1.stop_name} -> ${stop2.stop_name}`,\n          remark:\n            mul !== 1 ? `${mul.toFixed(1)}x traffic adjustment` : undefined,\n          startTime,\n          endTime,\n          startStopId: stopId1,\n          endStopId: stopId2,\n          next: this.computeMultilegBitRecur(endTime, nextLegs),\n        };\n      });\n    } else {\n      const trips = computeSingleLeg(\n        this.gtfsData,\n        startTime,\n        stopId1,\n        stopId2\n      ).slice(0, this.maxFerryOptions);\n      if (!trips.length) {\n        return [\n          {\n            id: `${stopId1}-${stopId2}-${+startTime}-error`,\n            type: LegType.ERROR,\n            text: `no valid route: ${stop1.stop_name} -> ${stop2.stop_name}`,\n            startTime,\n            endTime: startTime,\n            startStopId: stopId1,\n            endStopId: stopId2,\n            next: [],\n          },\n        ];\n      }\n      return trips.map((trip) => {\n        const stops = this.gtfsData.tripStopSequences[trip.trip_id];\n        // TODO: does not take day-wrapping into account\n        const [dh, dm, ds] = hmsStringToTriple(stops[0].departure_time);\n        const [ah, am, as] = hmsStringToTriple(stops[1].arrival_time);\n        const tripStart = datefns.set(startTime, {\n          hours: dh,\n          minutes: dm,\n          seconds: ds,\n        });\n        const tripEnd = datefns.add(\n          datefns.set(startTime, { hours: ah, minutes: am, seconds: as }),\n          { minutes: this.disembarkTimeMin }\n        );\n        return {\n          id: `${trip.trip_id}`,\n          type: LegType.FERRY,\n          text: trip.trip_headsign,\n          startTime: tripStart,\n          endTime: tripEnd,\n          startStopId: stopId1,\n          endStopId: stopId2,\n          next: this.computeMultilegBitRecur(tripEnd, nextLegs),\n        };\n      });\n    }\n  }\n\n  public computeMultileg(startTime: Date, stopIds: string[]): MultilegResult {\n    const legs = this.computeMultilegBitRecur(\n      startTime,\n      stopSequenceToLegs(stopIds)\n    );\n    const legSuccessors: LegRelationMap = {};\n    const legPredecessors: LegRelationMap = {};\n\n    function walk(leg: Leg, previous: Array<Leg> = []) {\n      const thisLegPredecessors = (legPredecessors[leg.id] =\n        legPredecessors[leg.id] || new Set());\n      previous.forEach((pleg) => thisLegPredecessors.add(pleg.id));\n      leg.next.forEach((nleg) => walk(nleg, [...previous, leg]));\n    }\n\n    legs.forEach((leg) => walk(leg));\n    Object.keys(legPredecessors).forEach((legId) => {\n      legPredecessors[legId].forEach((plegId) => {\n        const thisLegSuccessors = (legSuccessors[plegId] =\n          legSuccessors[plegId] || new Set());\n        thisLegSuccessors.add(legId);\n      });\n    });\n    return { legs, legSuccessors, legPredecessors };\n  }\n}\n","import { GTFSData, Trip } from \"./types\";\nimport { getValidServiceIdsForTime } from \"./utils\";\n\nexport function getValidTripsForStopPair(\n  gtfsData: GTFSData,\n  t: Date,\n  startStopId: string,\n  endStopId: string\n) {\n  const { tripStopFromToMap } = gtfsData;\n  const possibleTripIds = Array.from(\n    tripStopFromToMap[`${startStopId},${endStopId}`] || []\n  );\n  const availableServiceIds = getValidServiceIdsForTime(gtfsData, t);\n  const possibleTripServiceIds = new Set();\n  possibleTripIds.forEach((tripId) =>\n    possibleTripServiceIds.add(gtfsData.tripMap[tripId].service_id)\n  );\n  const validTrips = possibleTripIds\n    .map((tripId, index) => {\n      const trip = gtfsData.tripMap[tripId];\n      return trip && availableServiceIds.has(trip.service_id)\n        ? trip\n        : undefined;\n    })\n    .filter(Boolean) as Trip[];\n  // console.group(`${startStopId} -> ${endStopId} at ${t}`);\n  // console.log('possible trips', possibleTripIds.length);\n  // console.log('possible trips services', possibleTripServiceIds);\n  // console.log('available services', availableServiceIds);\n  // console.log('resulting valid trips', validTrips.length);\n  // console.groupEnd();\n  return validTrips;\n}\n","import { Leg, LegType } from \"../lib/multileg\";\nimport * as datefns from \"date-fns\";\nimport cx from \"classnames\";\nimport React from \"react\";\nimport { ViewProps } from \"./types\";\nimport { HTMLTable } from \"@blueprintjs/core\";\n\ninterface MultilegTableRowProps extends ViewProps {\n  leg: Leg;\n  parentLeg?: Leg;\n  depth: number;\n  accumulatedDuration?: number;\n}\n\nfunction getLegTypeLogo(leg: Leg): string {\n  switch (leg.type) {\n    case LegType.ERROR:\n      return \"‚ö°\";\n    case LegType.DRIVE:\n      return \"üöó\";\n    case LegType.FERRY:\n      return \"üö§\";\n    case LegType.WAIT:\n      return \"‚è≥\";\n  }\n  return \"???\";\n}\n\nfunction MultilegTableRow(props: MultilegTableRowProps) {\n  const {\n    leg,\n    parentLeg,\n    depth,\n    accumulatedDuration,\n    result,\n    highlight,\n    setHighlight,\n  } = props;\n  const typeLogo = getLegTypeLogo(leg);\n  const wait = parentLeg\n    ? datefns.differenceInMinutes(leg.startTime, parentLeg.endTime)\n    : undefined;\n  const legDuration = datefns.differenceInMinutes(leg.endTime, leg.startTime);\n  const newAccumulatedDuration = (accumulatedDuration || 0) + legDuration;\n  let final = leg.next.length === 0;\n  let initial = depth === 0;\n  const classes: { [key: string]: boolean } = { initial, final };\n  if (\n    highlight &&\n    !(highlight === leg.id || result.legPredecessors[leg.id].has(highlight))\n  ) {\n    classes.faded = true;\n  }\n  if (highlight === leg.id) {\n    classes.highlight = true;\n  }\n\n  return (\n    <>\n      <tr\n        className={cx(classes)}\n        onClick={() => setHighlight(highlight === leg.id ? undefined : leg.id)}\n      >\n        <td className=\"dt st\">{datefns.format(leg.startTime, \"HH:mm\")}</td>\n        <td className=\"dt et\">{datefns.format(leg.endTime, \"HH:mm\")}</td>\n        <td className=\"dt du\">{legDuration} min</td>\n        <td className=\"dt wt\">\n          {wait !== undefined && wait > 0 ? `${wait} min` : null}\n        </td>\n        <td className=\"tl\">{typeLogo}</td>\n        <td className=\"tx\">\n          <div style={{ paddingLeft: `${depth}em` }}>\n            {leg.text}\n            <span className=\"remark\">{leg.remark}</span>\n          </div>\n        </td>\n        <td className=\"dt adu\">\n          {final ? <>{newAccumulatedDuration} min</> : null}\n        </td>\n      </tr>\n      {leg.next.map((childLeg, i) => (\n        <MultilegTableRow\n          {...props}\n          leg={childLeg}\n          parentLeg={leg}\n          key={i}\n          depth={depth + 1}\n          accumulatedDuration={newAccumulatedDuration}\n        />\n      ))}\n    </>\n  );\n}\n\nexport function MultilegTable(props: ViewProps) {\n  return (\n    <HTMLTable id=\"t\" interactive>\n      <thead>\n        <tr>\n          <th>Start</th>\n          <th>End</th>\n          <th>Dur</th>\n          <th>Wait</th>\n          <th>Type</th>\n          <th>Description</th>\n          <th>Total Dur</th>\n        </tr>\n      </thead>\n      <tbody>\n        {props.result.legs.map((leg, i) => (\n          <MultilegTableRow {...props} leg={leg} key={i} depth={0} />\n        ))}\n      </tbody>\n    </HTMLTable>\n  );\n}\n","import {\n  Timeline as VisTimeline,\n  DataGroupCollectionType,\n  DataItemCollectionType,\n  TimelineOptions,\n} from \"vis-timeline\";\nimport \"vis-timeline/dist/vis-timeline-graph2d.min.css\";\nimport React from \"react\";\n\ntype VisEventCallback = (properties: any) => void;\n\nconst events = [\n  \"changed\",\n  \"click\",\n  \"contextmenu\",\n  \"currentTimeTick\",\n  \"doubleClick\",\n  \"drop\",\n  \"groupDragged\",\n  \"itemout\",\n  \"itemover\",\n  \"mouseDown\",\n  \"mouseMove\",\n  \"mouseOver\",\n  \"mouseUp\",\n  \"rangechange\",\n  \"rangechanged\",\n  \"select\",\n  \"timechange\",\n  \"timechanged\",\n];\n\ninterface TimelineProps {\n  options: TimelineOptions;\n  items: DataItemCollectionType;\n  groups?: DataGroupCollectionType;\n  eventHandlers?: { [key: string]: VisEventCallback };\n}\n\nconst Timeline: React.FC<TimelineProps> = ({\n  options,\n  items,\n  groups,\n  eventHandlers,\n}) => {\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const timelineRef = React.useRef<VisTimeline | null>(null);\n  const eventHandlersRef = React.useRef(eventHandlers);\n  React.useEffect(() => {\n    eventHandlersRef.current = eventHandlers;\n  }, [eventHandlers]);\n  const onEvent = React.useCallback((eventType, arg) => {\n    let handlers = eventHandlersRef.current;\n    if (handlers && eventType in handlers) {\n      handlers[eventType](arg);\n    }\n  }, []);\n  React.useEffect(() => {\n    if (containerRef.current) {\n      let timeline = timelineRef.current;\n      if (!timeline) {\n        timeline = new VisTimeline(containerRef.current, items, options);\n        events.forEach(\n          (eventType) =>\n            timeline && timeline.on(eventType, (arg) => onEvent(eventType, arg))\n        );\n        timelineRef.current = timeline;\n      } else {\n        timeline.setOptions(options);\n        timeline.setItems(items);\n      }\n      timeline.setGroups(groups);\n    }\n    return () => {\n      if (timelineRef.current) {\n        timelineRef.current.destroy();\n        timelineRef.current = null;\n      }\n    };\n  }, [onEvent, items, options, groups, containerRef]);\n  return <div ref={containerRef} />;\n};\n\nexport default Timeline;\n","import { Leg } from \"../lib/multileg\";\nimport Timeline from \"./ReactVisjsTimeline\";\nimport React from \"react\";\nimport { DataGroup, DataItem, TimelineOptions } from \"vis-timeline\";\nimport cx from \"classnames\";\nimport { ViewProps } from \"./types\";\n\nconst options: TimelineOptions = {\n  width: \"100%\",\n  stack: true,\n  showCurrentTime: true,\n  // zoomMin: 1000000,\n  // type: \"background\",\n  // format: {\n  //   minorLabels: {\n  //     minute: \"h:mma\",\n  //     hour: \"ha\",\n  //   },\n  // },\n};\n\nexport function MultilegTimeline({\n  gtfsData,\n  result,\n  highlight,\n  setHighlight,\n}: ViewProps) {\n  const { legs, legPredecessors } = result;\n  const [items, groups] = React.useMemo(() => {\n    const itemMap: { [id: string]: DataItem } = {};\n    const groupMap: { [id: string]: DataGroup } = {};\n    const itemClasses: { [id: string]: { [cls: string]: boolean } } = {};\n    const itemPredecessors: { [id: string]: Set<string> } = {};\n\n    function walk(leg: Leg, previous: Array<[Leg, string]>) {\n      const itemId = leg.id;\n      const groupId = `${leg.startStopId}-${leg.endStopId}`;\n      if (!(groupId in groupMap)) {\n        const endStopName = gtfsData.stopMap[leg.endStopId].stop_name;\n        groupMap[groupId] = {\n          id: groupId,\n          content: `${leg.type} to ${endStopName}`,\n        };\n      }\n      const classes = (itemClasses[itemId] = itemClasses[itemId] || {});\n      itemPredecessors[itemId] = legPredecessors[leg.id]; // just in case we accidentally alias item ids\n      classes[leg.type] = true;\n      if (!leg.next.length) {\n        classes.final = true;\n      }\n      if (!previous.length) {\n        classes.initial = true;\n      }\n      itemMap[itemId] = {\n        id: itemId,\n        group: groupId,\n        start: leg.startTime,\n        end: leg.endTime,\n        content: leg.text,\n      };\n      leg.next.forEach((l) => walk(l, [...previous, [leg, itemId]]));\n    }\n\n    legs.forEach((l) => walk(l, []));\n\n    if (highlight) {\n      for (let itemId in itemMap) {\n        if (itemId !== highlight && !itemPredecessors[itemId].has(highlight)) {\n          itemClasses[itemId].faded = true;\n        }\n      }\n    }\n    for (let itemId in itemClasses) {\n      if (itemMap[itemId]) {\n        itemMap[itemId].className = cx(itemClasses[itemId]);\n      }\n    }\n    return [[...Object.values(itemMap)], [...Object.values(groupMap)]];\n  }, [gtfsData.stopMap, legs, highlight]);\n  const onSelect = ({ items }: { items: string }) => setHighlight(items[0]);\n  return (\n    <Timeline\n      options={options}\n      items={items}\n      groups={groups}\n      eventHandlers={{ select: onSelect }}\n    />\n  );\n}\n","import { InterstopMap } from \"./lib/multileg\";\n\nconst turkuStopId = \"1\";\nconst parainenStopId = \"3\";\nconst nauvoProstvikStopId = \"4\";\nconst nauvoParnasStopId = \"29\";\nconst korpoRetaisStopId = \"6\";\nconst korpoCentrumStopId = \"24\";\nexport const defaultRoute = [\n  turkuStopId,\n  parainenStopId,\n  nauvoProstvikStopId,\n  nauvoParnasStopId,\n  korpoRetaisStopId,\n  korpoCentrumStopId,\n];\n\nexport const driveTravelPairs: [[string, string], number][] = [\n  [[nauvoProstvikStopId, nauvoParnasStopId], 30],\n  [[korpoRetaisStopId, korpoCentrumStopId], 30],\n  [[turkuStopId, parainenStopId], 45],\n];\nexport const driveTravelTimes: InterstopMap = {};\ndriveTravelPairs.forEach(([pair, duration]) => {\n  const [s1, s2] = pair;\n  driveTravelTimes[`${s1},${s2}`] = duration;\n  driveTravelTimes[`${s2},${s1}`] = duration;\n});\n","import * as datefns from \"date-fns\";\nimport React from \"react\";\nimport { DateInput, IDateFormatProps, TimePicker } from \"@blueprintjs/datetime\";\n\nconst jsDateFormatter: IDateFormatProps = {\n  // note that the native implementation of Date functions differs between browsers\n  formatDate: (date) => datefns.format(date, \"yyyy-MM-dd\"),\n  parseDate: (str) => new Date(str),\n};\n\ntype TimeConfigProps = { date: Date; onChange: (date: Date) => void };\n\nexport function TimeConfig({ date, onChange }: TimeConfigProps) {\n  return (\n    <div style={{ display: \"flex\" }}>\n      <div style={{ flex: 1 }}>\n        <DateInput\n          {...jsDateFormatter}\n          showActionsBar\n          value={date}\n          onChange={(date, isUserChange) =>\n            isUserChange ? onChange(date) : null\n          }\n        />\n      </div>\n      <div style={{ flex: 1 }}>\n        <TimePicker value={date} onChange={onChange} />\n      </div>\n    </div>\n  );\n}\n","import { GTFSData } from \"../lib/gtfs/types\";\nimport { InterstopMap } from \"../lib/multileg\";\nimport React from \"react\";\nimport { getDestinationStopsFromStop } from \"../lib/gtfs/utils\";\nimport { reverse, sortBy } from \"lodash\";\nimport { Button, HTMLSelect, Tag } from \"@blueprintjs/core\";\n\ninterface RouteConfigProps {\n  stopIds: string[];\n  setStopIds: (stopIds: string[]) => void;\n  gtfsData: GTFSData;\n  driveTravelTimes: InterstopMap;\n}\n\nexport function RouteConfig({\n  stopIds,\n  setStopIds,\n  gtfsData,\n  driveTravelTimes,\n}: RouteConfigProps) {\n  const lastStopId = stopIds.length ? stopIds[stopIds.length - 1] : null;\n  const nextStops = getDestinationStopsFromStop(gtfsData, lastStopId);\n  if (lastStopId) {\n    Object.keys(driveTravelTimes).forEach((key) => {\n      const [fromStopId, toStopId] = key.split(\",\");\n      if (fromStopId === lastStopId) {\n        nextStops.add(toStopId);\n      }\n    });\n  }\n  const nextSelect = (\n    <HTMLSelect\n      disabled={!nextStops.size}\n      onChange={(e) => {\n        const selection = e.target.value;\n        if (nextStops.has(selection)) {\n          setStopIds(stopIds.concat([selection]));\n        }\n      }}\n    >\n      <option value=\"\">Add...</option>\n      {sortBy(\n        Array.from(nextStops).map((stopId) => [\n          stopId,\n          gtfsData.stopMap[stopId].stop_name,\n        ]),\n        1\n      ).map(([stopId, name]) => (\n        <option key={stopId} value={stopId}>\n          {name}\n        </option>\n      ))}\n    </HTMLSelect>\n  );\n  return (\n    <>\n      <div>\n        {stopIds.map((stopId, idx) => (\n          <Tag\n            key={idx}\n            large\n            onRemove={() => setStopIds(stopIds.filter((sid) => sid !== stopId))}\n            style={{ marginRight: \".5em\" }}\n          >\n            {gtfsData.stopMap[stopId].stop_name}\n          </Tag>\n        ))}\n      </div>\n      <div style={{ marginTop: \".5em\" }}>\n        {nextSelect}{\" \"}\n        <Button\n          icon=\"refresh\"\n          disabled={!stopIds.length}\n          onClick={() => setStopIds(reverse([...stopIds]))}\n        >\n          Reverse\n        </Button>{\" \"}\n        <Button\n          icon=\"delete\"\n          disabled={!stopIds.length}\n          onClick={() => setStopIds([])}\n        >\n          Clear\n        </Button>\n      </div>\n    </>\n  );\n}\n","import { Card, FormGroup, H5, Slider } from \"@blueprintjs/core\";\nimport { TimeConfig } from \"./TimeConfig\";\nimport { RouteConfig } from \"./RouteConfig\";\nimport { driveTravelTimes } from \"../tribalKnowledge\";\nimport React from \"react\";\nimport { GTFSData } from \"../lib/gtfs/types\";\n\ninterface ConfigSectionProps {\n  gtfsData: GTFSData;\n  date: Date;\n  onChangeDate: (value: Date) => void;\n  stopIds: string[];\n  setStopIds: (value: string[]) => void;\n  setDisembarkTimeMin: (value: number) => void;\n  disembarkTimeMin: number;\n  setDriveTimeMultiplier: (v: number) => void;\n  driveTimeMultiplier: number;\n}\n\nexport function ConfigSection(props: ConfigSectionProps) {\n  return (\n    <div style={{ display: \"flex\" }}>\n      <Card style={{ flex: 1, margin: \".5em\" }}>\n        <H5>Departure Time</H5>\n        <TimeConfig date={props.date} onChange={props.onChangeDate} />\n      </Card>\n      <Card style={{ flex: 3, margin: \".5em\" }}>\n        <H5>Route</H5>\n        <RouteConfig\n          stopIds={props.stopIds}\n          setStopIds={props.setStopIds}\n          gtfsData={props.gtfsData}\n          driveTravelTimes={driveTravelTimes}\n        />\n      </Card>\n      <Card style={{ flex: 1, margin: \".5em\" }}>\n        <H5>Options</H5>\n        <FormGroup label=\"Disembarkation time (min)\">\n          <Slider\n            min={0}\n            max={20}\n            stepSize={1}\n            labelStepSize={5}\n            onChange={props.setDisembarkTimeMin}\n            value={props.disembarkTimeMin}\n          />\n        </FormGroup>\n        <FormGroup label=\"Drive time multiplier\">\n          <Slider\n            min={0}\n            max={2}\n            stepSize={0.1}\n            labelStepSize={0.5}\n            onChange={props.setDriveTimeMultiplier}\n            value={props.driveTimeMultiplier}\n          />\n        </FormGroup>\n      </Card>\n    </div>\n  );\n}\n","import { Leg, LegType } from \"../lib/multileg\";\nimport cytoscape, { ElementDefinition } from \"cytoscape\";\nimport klay from \"cytoscape-klay\";\nimport CytoscapeComponent from \"react-cytoscapejs\";\n\nimport * as datefns from \"date-fns\";\nimport React from \"react\";\nimport { ViewProps } from \"./types\";\n\ncytoscape.use(klay);\n\nexport function MultilegGraph({ gtfsData, result }: ViewProps) {\n  const { legs } = result;\n  const nodes: { [id: string]: ElementDefinition } = {};\n  const edges: { [id: string]: ElementDefinition } = {};\n\n  function stopNode(stopId: string): string {\n    const id = `stop-${stopId}`;\n    if (!nodes[id]) {\n      const stop = gtfsData.stopMap[stopId];\n      nodes[id] = {\n        data: { id, label: stop.stop_name },\n      };\n    }\n    return id;\n  }\n\n  function walk(leg: Leg, previous: Array<[Leg, string, string]>) {\n    let startId = \"\",\n      endId = \"\";\n    if (!previous.length) {\n      startId = stopNode(leg.startStopId);\n    } else {\n      startId = previous[previous.length - 1][2];\n    }\n    if (false) {\n      //!leg.next.length) {\n      endId = stopNode(leg.endStopId);\n    } else {\n      endId = `${leg.endStopId}-${leg.endTime}`;\n      const stop = gtfsData.stopMap[leg.endStopId];\n      nodes[endId] = {\n        data: {\n          id: endId,\n          label: `${stop.stop_name} at ${datefns.format(leg.endTime, \"HH:mm\")}`,\n        },\n      };\n    }\n\n    const edgeId = `${startId}-${endId}-${leg.startTime}`;\n    const legDuration = datefns.differenceInMinutes(leg.endTime, leg.startTime);\n    const parentLeg = previous.length\n      ? previous[previous.length - 1][0]\n      : undefined;\n    const wait = parentLeg\n      ? datefns.differenceInMinutes(leg.startTime, parentLeg.endTime)\n      : undefined;\n    let edgeLabel =\n      (wait ? `${wait}min wait, ` : \"\") + `${legDuration}min ${leg.type}`;\n    edges[edgeId] = {\n      data: {\n        id: edgeId,\n        source: startId,\n        target: endId,\n        label: edgeLabel,\n      },\n      classes: `${leg.type}`,\n    };\n    leg.next.forEach((l) => walk(l, [...previous, [leg, startId, endId]]));\n  }\n\n  legs.forEach((l) => walk(l, []));\n\n  return (\n    <CytoscapeComponent\n      elements={[...Object.values(nodes), ...Object.values(edges)]}\n      stylesheet={[\n        {\n          selector: \"node\",\n          style: {\n            label: \"data(label)\",\n          },\n        },\n        {\n          selector: \"edge\",\n          style: {\n            label: \"data(label)\",\n            \"curve-style\": \"straight\",\n          },\n        },\n        {\n          selector: \"edge.ferry\",\n          style: {\n            \"line-color\": \"navy\",\n          },\n        },\n      ]}\n      layout={{\n        name: \"klay\",\n        nodeDimensionsIncludeLabels: true,\n        klay: {\n          direction: \"RIGHT\",\n          edgeRouting: \"SPLINES\",\n        },\n      }}\n      style={{ width: \"100%\", height: \"600px\", border: \"1px solid orange\" }}\n    />\n  );\n}\n","import React from \"react\";\nimport { GTFSData, RawGTFSData } from \"./lib/gtfs/types\";\nimport {\n  augmentRawGTFSData,\n  filterRawGTFSData,\n  parseMultipleUrls,\n} from \"./lib/gtfs/parse\";\nimport { MultilegMachine } from \"./lib/multileg\";\nimport * as datefns from \"date-fns\";\nimport { MultilegTable } from \"./components/MultilegTable\";\nimport { MultilegTimeline } from \"./components/MultilegTimeline\";\nimport { defaultRoute, driveTravelTimes } from \"./tribalKnowledge\";\nimport { NonIdealState, Tabs, Tab, Button } from \"@blueprintjs/core\";\nimport { uniq } from \"lodash\";\nimport { ConfigSection } from \"./components/ConfigSection\";\nimport { MultilegGraph } from \"./components/MultilegGraph\";\nimport { ViewProps } from \"./components/types\";\n\nasync function getGTFSData(cutoffDate?: Date): Promise<GTFSData> {\n  let rawData = await parseMultipleUrls<RawGTFSData>({\n    agency: require(\"./data/gtfs/agency.txt\"),\n    calendar: require(\"./data/gtfs/calendar.txt\"),\n    calendarDates: require(\"./data/gtfs/calendar_dates.txt\"),\n    frequencies: require(\"./data/gtfs/frequencies.txt\"),\n    routes: require(\"./data/gtfs/routes.txt\"),\n    stopTimes: require(\"./data/gtfs/stop_times.txt\"),\n    stops: require(\"./data/gtfs/stops.txt\"),\n    trips: require(\"./data/gtfs/trips.txt\"),\n  });\n  if (cutoffDate) {\n    filterRawGTFSData(rawData, cutoffDate);\n  }\n  return augmentRawGTFSData(rawData);\n}\n\nfunction App() {\n  const [gtfsData, setGtfsData] = React.useState<GTFSData | undefined>();\n  React.useEffect(() => {\n    getGTFSData(new Date(2020, 0)).then(setGtfsData);\n  }, []);\n\n  if (gtfsData === undefined) return null;\n  return <Core gtfsData={gtfsData} />;\n}\n\nfunction ResultTabs(props: {\n  id: string;\n  viewProps: ViewProps;\n  renderButton?: boolean;\n  buttonActive?: boolean;\n  onButtonClick?: () => void;\n}) {\n  return (\n    <Tabs id={props.id} renderActiveTabPanelOnly>\n      <Tab\n        id=\"timeline\"\n        title=\"Timeline\"\n        panel={<MultilegTimeline {...props.viewProps} />}\n      />\n      <Tab\n        id=\"table\"\n        title=\"Table\"\n        panel={<MultilegTable {...props.viewProps} />}\n      />\n      <Tab\n        id=\"graph\"\n        title=\"Graph\"\n        panel={<MultilegGraph {...props.viewProps} />}\n      />\n      {props.renderButton ? (\n        <>\n          <Tabs.Expander />\n          <Button\n            icon=\"split-columns\"\n            active={props.buttonActive}\n            onClick={props.onButtonClick}\n          >\n            Split\n          </Button>\n        </>\n      ) : null}\n    </Tabs>\n  );\n}\n\nfunction Core({ gtfsData }: { gtfsData: GTFSData }) {\n  const [highlight, setHighlight] = React.useState<string | undefined>();\n  const [startTime, setStartTime] = React.useState(() => new Date()); //new Date(2020, 3, 13, 12, 10, 0));\n  const [stopIds, setStopIds] = React.useState(() => [...defaultRoute]);\n  const [disembarkTimeMin, setDisembarkTimeMin] = React.useState(3);\n  const [driveTimeMultiplier, setDriveTimeMultiplier] = React.useState(1.5);\n  const [splitEnabled, setSplitEnabled] = React.useState(false);\n  const mlm = React.useMemo(\n    () =>\n      new MultilegMachine(\n        gtfsData,\n        driveTravelTimes,\n        uniq([1, driveTimeMultiplier]),\n        disembarkTimeMin\n      ),\n    [gtfsData, disembarkTimeMin, driveTimeMultiplier]\n  );\n  const result = React.useMemo(() => mlm.computeMultileg(startTime, stopIds), [\n    mlm,\n    startTime,\n    stopIds,\n  ]);\n  const viewProps: ViewProps = { gtfsData, result, highlight, setHighlight };\n  const resultView = result.legs.length ? (\n    <>\n      <h1>\n        {datefns.format(startTime, \"dd.MM.yyyy HH:mm\")}\n        <br />\n        {stopIds\n          .map((stopId) => gtfsData.stopMap[stopId])\n          .map((s) => s.stop_name)\n          .join(\" - \")}\n      </h1>\n      <div style={{ display: \"flex\" }}>\n        <div style={{ flex: 1 }}>\n          <ResultTabs\n            id=\"tabs1\"\n            viewProps={viewProps}\n            renderButton\n            buttonActive={splitEnabled}\n            onButtonClick={() => setSplitEnabled(!splitEnabled)}\n          />\n        </div>\n\n        {splitEnabled ? (\n          <div style={{ flex: 1 }}>\n            <ResultTabs id=\"tabs2\" viewProps={viewProps} />\n          </div>\n        ) : null}\n      </div>\n    </>\n  ) : (\n    <NonIdealState icon=\"search\" title=\"No results\" />\n  );\n  return (\n    <div className=\"App\">\n      <ConfigSection\n        date={startTime}\n        onChangeDate={setStartTime}\n        stopIds={stopIds}\n        setStopIds={setStopIds}\n        gtfsData={gtfsData}\n        setDisembarkTimeMin={setDisembarkTimeMin}\n        disembarkTimeMin={disembarkTimeMin}\n        setDriveTimeMultiplier={(v) =>\n          setDriveTimeMultiplier(parseFloat(v.toFixed(2)))\n        }\n        driveTimeMultiplier={driveTimeMultiplier}\n      />\n      {resultView}\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport \"normalize.css\";\nimport \"@blueprintjs/core/lib/css/blueprint.css\";\nimport \"@blueprintjs/datetime/lib/css/blueprint-datetime.css\";\nimport \"@blueprintjs/icons/lib/css/blueprint-icons.css\";\n\nimport App from \"./App\";\n//import * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// serviceWorker.register();\n"],"sourceRoot":""}